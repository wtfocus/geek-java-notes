[toc]

## 系统性能优化

### 性能优化

1.   性能
     -   吞吐与延迟
     -   量化
     -   20/80 原则
     -   过早优化是万恶之源
     -   脱离场景谈性能都是耍流氓
2.   业务系统性能优化的核心 -- DB/SQL 优化
     -   业务分类
         -   计算密集型
         -   数据密集型
     -   一般来说，DB/SQL 操作的消耗在一次处理中占比最大
     -   业务系统发展的不同阶段和时期，性能瓶颈要点不同。

### 关系数据库 MySQL

### 深入数据库原理

1.   MySQL 架构图

     -   ![image-20211210203106599](imgs/image-20211210203106599.png)

2.   MySQL 存储

     -   独占模式

         >   日志组文件:ib_logfile0 和 ib_logfile1，默认均为5M 
         >
         >   表结构文件:*.frm
         >
         >   独占表空间文件:*.ibd 4)、字符集和排序规则文件:db.opt
         >
         >   binlog 二进制日志文件:记录主数据库服务器的 DDL 和 DML 操作 
         >
         >   二进制日志索引文件:master-bin.index

     -   共享模式 innodb_file_per_table=OFF

         >   数据都在 ibdata1

3.   MySQL 简化执行流程

     -   ![image-20211210203626094](imgs/image-20211210203626094.png)

4.   MySQL 详细执行流程

     -   ![image-20211210203853414](imgs/image-20211210203853414.png)

5.   MySQL 执行引擎和状态

     -   ![image-20211210204213264](imgs/image-20211210204213264.png)

6.   MySQL 对 SQL 执行顺序

     -   ![image-20211210204717927](imgs/image-20211210204717927.png)

7.   MySQL 索引原理

     -   ![image-20211210204857619](imgs/image-20211210204857619.png)

###  MySQL 配置优化*

1.   参数配置优化

     -   连接请求的变量

         >   max_connections
         >
         >   back_log 
         >
         >   wait_timeout 和 interative_timeout

     -   缓冲区变量

         >   key_buffer_size 
         >
         >   query_cache_size (查询缓存简称 QC) 
         >
         >   max_connect_errors 
         >
         >   sort_buffer_size 8、max_allowed_packet=32M 
         >
         >   join_buffer_size=2M 
         >
         >   thread_cache_size=300

     -   配置 Innodb 的几个变量

         >   innodb_buffer_pool_size=128M 
         >
         >   innodb_flush_log_at_trx_commit 
         >
         >   innodb_thread_concurrency=0 
         >
         >   innodb_log_buffer_size 
         >
         >   innodb_log_file_size=50M 
         >
         >   innodb_log_files_in_group=3 
         >
         >   read_buffer_size=1M 
         >
         >   read_rnd_buffer_size=16M 
         >
         >   bulk_insert_buffer_size=64M 
         >
         >   binary log

### 数据库设计优化*

1.   最佳实践
     -   如何恰当选择引擎?
     -   库表如何命名?
     -   如何合理拆分宽表?
     -   如何选择恰当数据类型: 明确、尽量小
         -   char、varchar 的选择
         -   (text/blob/clob)的使用问题? 
         -   文件、图片是否要存入到数据库? 
         -   时间日期的存储问题?
         -   数值的精度问题?
     -   是否使用外键、触发器?
     -   唯一约束和索引的关系?
     -   是否可以冗余字段?
     -   是否使用游标、变量、视图、自定义函数、存储过程? - 自增主键的使用问题?
     -   能够在线修改表结构(DDL 操作)?
     -   逻辑删除还是物理删除?
     -   要不要加 create_time,update_time 时间戳?
     -   数据库碎片问题?
     -   如何快速导入导出、备份数据?

### MySQL 事务 && 锁

1.   事务可靠性模型 -- ACID
     -   Atomicity:  原子性，一次事务中的操作要么全部成功，要么全部失败。 
     -   Consistency:  一致性，跨表、跨行、跨事务，数据库始终保持一致状态。 
     -   Isolation:  隔离性，可见性，保护事务不会互相干扰，包含4种隔离级别。 
     -   Durability:  持久性，事务提交成功后，不会丢数据。如电源故障，系统崩溃。
2.   InnoDB 
3.   表级锁
4.   行级锁
5.   死锁
6.   4 种事务隔离级别
     -   读未提交: READ UNCOMMITTED
     -   读已提交: READ COMMITTED
     -   可重复读: REPEATABLE READ
     -   可串行化: SERIALIZABLE



