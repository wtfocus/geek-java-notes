[toc]

## 并发编程

### 多线程基础

1. 起源

    - 摩尔定律失效 -> 多核＋分布式时代

        >   摩尔定律
        >
        >   性能每 18个月可以增长一倍，价格没有增长多少。
        >
        >   
        >
        >   业务需求不断增长
        >
        >   
        >
        >   --> 多核＋分布式时代

2. 多核时代的编程更有挑战

3. Java 线程的创建过程

    -   ![image-20211125192638711](imgs/image-20211125192638711.png)

### Java 多线程

1.   基础接口 Runnable 

     -   守护线程 setDeamon

     -   启动方式 start

     -   接口定义

         >   interface Runnable {
         >
         >   abstract void run();
         >
         >   }

     -   示例 1

         >   Runnable task = new Runnable() {
         >
         >   @Override
         >
         >   public void run() {
         >
         >   ...
         >
         >   }
         >
         >   }
         >   

     -   示例 2

         >   public class Task implements Runnable {
         >
         >   ....
         >
         >   }

     -   辨析

         >   Thread#start() 创建新线程
         >
         >   Thread#run() 本线程调用

2.   线程状态

     -   ![image-20211128165337095](imgs/image-20211128165337095.png)

3.   Thread 类

     -   ![image-20211128165358132](imgs/image-20211128165358132.png)

4.   wait & notify

     -   ![image-20211128165611839](imgs/image-20211128165611839.png)

     -   sleep vs wait

         >   Thread#sleep 释放 CPU
         >
         >   Object#wait 释放对象锁
     
5.   Thread 的状态改变操作

     -   Thread.sleep，线程进入　TIME_WAITING 状态
     -   Thread.yield，线程由运行状态 -> 就绪状态
     -   join，线程进入　WAITING/TIMED_WAITING 状态
     -   obj.wait，
     -   obj.notify，

6.   Thread 的中断与异常处理

     -   线程内部自己处理异常，不溢出到外层（Future 可以封装）

     -   如果线程被 wait/join/sleep 三种方法之一阻塞，此时调用该线程的 interrupt() 方法，该线程将抛出一个 InterruptException 中断异常（该线程必须事先预备处理此异常），从而提早终结被阻塞状态。

     -   如果是计算密集型的操作怎么办？

         >   分段处理，每个片段检查一下状态，是不是要终止。

7.   Thread 状态

     -   ![image-20211128171111273](imgs/image-20211128171111273.png)

### 线程安全

1.   多线程执行会遇到什么问题？

     -   ![image-20211128172218471](imgs/image-20211128172218471.png)

2.   并发相关的性质

     -   原子性

         >   这些操作是不可被中断的，要么执行，要么不执行。
         >
         >   
         >
         >   对基本数据类型的变量的读取和赋值操作是原子性操作。

     -   可见性

         >   Java 提供了 volatile 来保证可见性（volatile 并不能保证原子性）
         >
         >   当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。
         >
         >   另外，synchronized 和 Lock 也能够保证可见性。
         >
         >   它们能保证同一时刻，只有一个线程获取锁然后执行同步代码，并在释放锁之前会将对变量的修改刷新到主存中。 

     -   有序性

         >   Java 允许编译器和处理器对指令进行重排序，但，重排序过程并不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。
         >
         >   
         >
         >   可以通过 volatile/synchronized/Lock 保证一定的“有序性”
         >
         >   
         >
         >   happens-before 原则（先行发生原则）
         >
         >   1.   程序次序规则
         >   2.   锁定规则
         >   3.   Volatile 规则
         >   4.   传递规则
         >   5.   线程启动规则
         >   6.   线程中断规则
         >   7.   线程终结规则
         >   8.   对象终结规则

3.   一个例子，多线程计数

     -   class Counter

4.   synchronized 

     -   使用对象头标记字
         -   ![image-20211128175337814](imgs/image-20211128175337814.png)
     -   synchronized 方法优化
         -   ![image-20211128175315964](imgs/image-20211128175315964.png)
     -   偏向锁　BiaseLock

5.   volatile

     -   每次读取都强制从主内存刷数据
     -   适用场景：单个线程写；多个线程读
     -   原则：能不用就不用，尽量少用。不确定的时候也不用。
     -   替代方案：Atomic 原子操作类

6.   final

     -   定义

         -   ![image-20211128180508921](imgs/image-20211128180508921.png)

     -   思考

         >   final 声明的引用类型与原生类型在处理时有什么区别？

     -   Java 里的常量替换。写代码最大化用 final 是个好习惯。

### 线程池原理与应用

1.   线程池

     -   Excutor 执行者，顶层接口
     -   ExcutorService 接口 API
     -   ThreadFactory 线程工厂
     -   ThreadPoolExector
     -   Excutors 工具类，创建线程

2.   Excutor

     -   方法

         -   ![image-20211128195957902](imgs/image-20211128195957902.png)

     -   结构

         -   ![image-20211128200515817](imgs/image-20211128200515817.png)

     -   submit vs execte

         >   submit 方法 -> 有返回值，用 Future 封装 
         >
         >   execute 方法 -> 无返回值
         >
         >   
         >
         >   submit 方法还异常可以在主线程中 get 捕获到 
         >
         >   execute 方法执行任务是捕捉不到异常的

3.   ExecutorService

     -   方法

         -   ![image-20211128200747343](imgs/image-20211128200747343.png)

     -   停止方法 vs

         >   shutdown(): 停止接收新任务，原来的任务继续执行
         >
         >   shutdownNow(): 停止接收新任务，原来的任务停止执行
         >
         >   boolean awaitTermination(timeOut, unit): 阻塞当前线程，返回是否线程都执行完
     
4.   ThreadPoolExecutor

     -   提交任务逻辑

         -   ![image-20211128201411692](imgs/image-20211128201411692.png)

     -   理解

         >   1.   判断 corePoolSize
         >   2.   加入 workQueue
         >   3.   判断 maximumPoolSize
         >   4.   执行拒绝策略处理器

5.   线程池参数

     -   缓冲队列，BlockingQueue 是双缓冲队列。

         -   ArrayBlockingQueue

             >   规定大小
             >
             >   FIFO

         -   LinkedBlockingQueue

             >   不固定大小，建议指定大小。
             >
             >   FIFO

         -   PriorityBlockingQueue

             >   类似LinkedBlockingQueue
             >
             >   顺序依据对象的自然顺序或构造函数的 Comparator 决定

         -   SynchronizedQueue

             >   特殊的 BlockingQueue 对其操作必须是放和取交替完成。
         
     -   拒绝策略

         -   ThreadPoolExecutor.AbortPolicy（常用）

             >   丢弃任务 & RejectedExecutionException

         -   ThreadPoolExecutor.DiscardPolicy

             >   丢弃任务

         -   ThreadPoolExecutor.DiscardOldestPolicy

             >   丢弃队列最前面的任务

         -   ThreadPoolExecutor.CallerRunsPolicy（最常用）

             >   由调用线程（提交任务的线程）处理该任务

6.   ThreadFactory

     -   代码

         -   ```java
             public class CustomThreadFactory implements ThreadFactory {
                 private AtomicInteger serial = new AtomicInteger(0);
             
                 @Override
                 public Thread newThread(Runnable r) {
                     Thread thread = new Thread(r);
                     thread.setDaemon(true); // 根据需要，设置守护线程
                     thread.setName("CustomeThread-" + serial.getAndIncrement());
                     return thread;
                 }
             }
             ```

7.   ThreadPoolExecutor

     -   属性 & 方法
         -   ![image-20211128234715553](imgs/image-20211128234715553.png)
     -   示例，创建线程池
         -   ![image-20211128235128752](imgs/image-20211128235128752.png)

8.   创建线程池方法

     -   newSingleThreadExecutor

         >   创建一个单线程的线程池

     -   newFixedThreadPool

         >   创建固定大小的线程池

     -   newCachedThreadPool

         >   创建一个可缓存的线程池

     -   newScheduledThreadPool

         >   创建一个大小无限的线程池
         >
         >   定时&周期性执行任务

9.    经验，固定线程池大小设置（核心数为 N）

     -   CPU 密集型，N 或 N +1 
     -   IO 密集型，2N 或 2N + 2

10.   Callable - 基础接口

     -   方法

         -   ![image-20211129000655173](imgs/image-20211129000655173.png)

     -   示例

         -   ```java
             public class RandomSleepTask implements Callable<Integer> {
                 @Override
                 public Integer call() throws Exception {
                     Integer sleep = new Random().nextInt(10000);
                     TimeUnit.MILLISECONDS.sleep(sleep);
                     return sleep;
                 }
             }
             ```

         -   

     -   Runnable vs Callable

         >   Runnable#run() 没有返回值
         >
         >   Callable#call() 有返回值

11.   Future - 基础接口

      -   方法

          -   ![image-20211129000940921](imgs/image-20211129000940921.png)

      -   示例

          -   ```java
              public static void main(String[] args) throws Exception {
                  Callable<Integer> task = new RandomSleepTask();
                  ExecutorService executorService = initThreadPoolExecutor();
                  Future<Integer> future1 = executorService.submit(task);
                  Future<Integer> future2 = executorService.submit(task); // 等待执行结果
                  Integer result1 = future1.get(1, TimeUnit.SECONDS);
                  Integer result2 = future2.get(1, TimeUnit.SECONDS);
                  System.out.println("result1=" + result1);
                  System.out.println("result2=" + result2);
              }
              ```

          -   
